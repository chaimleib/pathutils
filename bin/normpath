#!/bin/bash
path="$1"

[[ -z "$path" ]] && echo '.' && exit 0

function startswith() {
    local prefix="$1"
    local str="$2"
    [[ "$str" == "$prefix"* ]]
}

function joinstr() {
    local sep="$1"
    local args=("$@")
    local num_args=${#@}
    [[ $num_args -eq 1 ]] && printf '\n' && return 0
    local i=1
    while [[ $i -lt $((num_args-1)) ]]; do
        printf %s"$sep" "${args[$i]}"
        ((i++))
    done
    echo "${args[$num_args-1]}"
}

function repeatstr() {
    local str="$1"
    local num=${2-0}
    [[ $num -gt 0 ]] && printf "$str"%.s $(eval echo {1..$num})
    printf '\n'
}

function splitstr() {
    local delim="$2"
    local result
    IFS="$delim" read -ra result < <(echo "$1")
    for s in "${result[@]}"; do echo "$s"; done
}

# POSIX allows one or two initial slashes, but treats three or more
# as a single slash
initial_slashes=0
startswith / "$path" && initial_slashes=1
startswith // "$path" && ! startswith /// "$path" && initial_slashes=2

new_comps=()
comps=()
while IFS= read -r; do comps+=("$REPLY"); done < <(splitstr "$path" /)

for comp in "${comps[@]}"; do    
    [[ -z "$comp" || "$comp" == "." ]] && continue
    num_new_comps=${#new_comps[@]}
    if [[ "$comp" != ".." ]] ||
        [[ $initial_slashes -eq 0 && $num_new_comps -eq 0 ]] ||
        [[ $num_new_comps -ne 0 && "${new_comps[$num_new_comps-1]}" == ".." ]]
    then
        new_comps+=("$comp")
    elif [[ $num_new_comps -ne 0 ]]; then
        unset new_comps[$num_new_comps-1]
    fi
done

path="$(joinstr / "${new_comps[@]}")"
[[ $initial_slashes -ne 0 ]] && path="$(repeatstr / $initial_slashes)$path"

[[ -z "$path" ]] && echo '.' || echo "$path"
