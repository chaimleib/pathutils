#!/bin/bash
path="$1"

[[ -z "$path" ]] && echo '.' && exit 0

function debug() { echo "$1 => \"$(eval echo \$$1)\"" >&2; }

function startswith() {
    local prefix="$1"
    local str="$2"
    [[ "$str" == "$prefix"* ]]
}

function joinstr() {
    local sep="$1"
    local args=("$@")
    local num_args=${#@}
    [[ $num_args -eq 1 ]] && printf '\n' && return 0
    local i=1
    while [[ $i -lt $((num_args-1)) ]]; do
        printf %s"$sep" "${args[$i]}"
        ((i++))
    done
    echo "${args[$num_args-1]}"
}

function repeatstr() {
    local str="$1"
    local num=${2-0}
    [[ $num -gt 0 ]] && printf "$str"%.s $(eval echo {1..$num})
    printf '\n'
}

function splitstr() {
    local str="$1"
    local delim="$2"
    if [[ -z "$delim" ]]; then
        echo "splitstr: no delimiter provided" >&2
        return 1
    fi
    while [[ "$str" == *"$delim"* ]]; do
        echo "${str%%"${delim}"*}"
        str="${str#*"${delim}"}"
    done
    echo "$str"
}

# POSIX allows one or two initial slashes, but treats three or more
# as a single slash
initial_slashes=0
startswith / "$path" && initial_slashes=1
startswith // "$path" && ! startswith /// "$path" && initial_slashes=2

result=""
while read -r comp; do
    [[ -z "$comp" || "$comp" == "." ]] && continue
    if [[ "$comp" != ".." ]] ||
        [[ $initial_slashes -eq 0 && -z "$result" ]] ||
        [[ "$result" == ".." || "$result" == *"/.." ]]
    then
        [[ -n "$result" ]] && result+="/"
        result+="$comp"
    elif [[ -n "$result" ]]; then
        [[ "$result" == */* ]] && result="${result%/*}" || result=""
    fi
done <<< "$(splitstr "$path" /)"

result="$(repeatstr / $initial_slashes)${result}"
[[ -z "$result" ]] && result="."
echo "$result"
